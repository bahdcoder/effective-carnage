/* Partly generated by AI */
import { IgnitorCli } from "@/server/ignitor/ignitor-cli"
import { command } from "@drizzle-team/brocli"
import fs from "node:fs/promises"
import path from "node:path"
import type { Logger } from "pino"

/**
 * Recursively finds all JavaScript files in a directory
 * @param dir Directory to search
 * @returns Array of file paths
 */
async function findJsFiles(dir: string): Promise<string[]> {
	const files: string[] = []
	const entries = await fs.readdir(dir, { withFileTypes: true })

	for (const entry of entries) {
		const fullPath = path.join(dir, entry.name)

		if (entry.isDirectory()) {
			files.push(...(await findJsFiles(fullPath)))
		} else if (entry.isFile() && entry.name.endsWith(".js")) {
			files.push(fullPath)
		}
	}

	return files
}

/**
 * Calculates the relative path from a file to the core directory
 * @param filePath Path of the file
 * @returns Relative path to core directory
 */
function getRelativePathToCore(filePath: string): string {
	// Get the directory of the file
	const fileDir = path.dirname(filePath)

	// Calculate relative path from file directory to the build directory
	const relativeToBuild = path.relative(fileDir, "build")

	// If we're already in the build directory, the relative path is empty
	// Otherwise, we need to go up to the build directory
	return relativeToBuild === "" ? "./" : `${relativeToBuild}/`
}

/**
 * Fixes import statements in a file
 * @param filePath Path of the file to fix
 */
async function fixImportsInFile(
	filePath: string,
	logger: Logger,
): Promise<void> {
	try {
		// Read file content
		const content = await fs.readFile(filePath, "utf-8")

		// Calculate relative paths
		const relativeToCore = getRelativePathToCore(filePath)

		// Replace @/ with relative path to core
		// Only match @/ that is part of an import/export statement and not part of a package name
		const fixedContent = content
			.replace(
				/(from\s+["']|import\s+["']|export\s+(?:(?:{\s*[\w\s,]+\s*}|\*\s+as\s+\w+)\s+from\s+["']))@\/(.*?)["']/g,
				(_match, importPrefix, importPath) => {
					return `${importPrefix}${relativeToCore}${importPath}"`
				},
			)
			.replace(
				/(from\s+["']|import\s+["']|export\s+(?:(?:{\s*[\w\s,]+\s*}|\*\s+as\s+\w+)\s+from\s+["']))@app\/(.*?)["']/g,
				(_match, importPrefix, importPath) => {
					return `${importPrefix}${relativeToCore}core/app/${importPath}"`
				},
			)

		// Write modified content back to file
		if (content !== fixedContent) {
			await fs.writeFile(filePath, fixedContent, "utf-8")
			return logger.info(`Fixed imports in ${filePath}`)
		}

		logger.info(`No changes needed in ${filePath}`)
	} catch (error) {
		console.error(`Error processing ${filePath}:`, error)
	}
}

export function fixTypescriptImportsCommand() {
	return command({
		name: "fix_typescript_imports",
		desc: "Rewrite import aliases in bundled files.",
		async handler() {
			const ignitor = new IgnitorCli()

			await ignitor.initialize()
			const { logger } = ignitor.ctx()
			logger.info("Fixing TypeScript imports in build directory...")

			try {
				// Find all JS files in the build directory
				const files = await findJsFiles("build")
				logger.info(`Found ${files.length} JavaScript files`)

				// Process each file
				await Promise.all(files.map((file) => fixImportsInFile(file, logger)))

				logger.info("Import paths fixed successfully!")
			} catch (error) {
				logger.error("Error fixing imports:", error)
			}

			await ignitor.shutdown()
		},
	})
}
